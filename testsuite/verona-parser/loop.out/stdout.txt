(class
  ()
  []
  ()
  [
    (class
      $module-0
      []
      ()
      [
        (using (typeref [ (modulename $module-1 []) ]))
        (function
          foo
          (lambda
            [ (typeparam T () ()) ]
            [ (param a (typeref [ (typename T []) ]) ()) ]
            ()
            []))
        (function
          f
          (lambda
            [ (typeparam T () ()) ]
            [ (param x (typeref [ (typename T []) ]) ()) ]
            ()
            [
              (var a)
              (let $0)
              (assign (ref $0) (int 0))
              (assign (ref a) (ref $0))
              (let $1)
              (assign
                (ref $1)
                (lambda
                  []
                  []
                  ()
                  [
                    (freevar a)
                    (let $0)
                    (assign (ref $0) (int 5))
                    (let $1)
                    (assign
                      (ref $1)
                      (select (ref a) [ (typename < []) ] (ref $0)))
                    (ref $1)
                  ]))
              (let $2)
              (assign (ref $2) (select () [ (typename while []) ] (ref $1)))
              (let $3)
              (assign
                (ref $3)
                (lambda
                  []
                  []
                  ()
                  [
                    (freevar a)
                    (let $0)
                    (assign (ref $0) (int 1))
                    (let $1)
                    (assign
                      (ref $1)
                      (select (ref a) [ (typename + []) ] (ref $0)))
                    (assign (ref a) (ref $1))
                    (let $2)
                    (assign (ref $2) (int 2))
                    (let $3)
                    (assign
                      (ref $3)
                      (select (ref a) [ (typename < []) ] (ref $2)))
                    (let $4)
                    (assign (ref $4) (select () [ (typename if []) ] (ref $3)))
                    (let $5)
                    (assign
                      (ref $5)
                      (lambda
                        []
                        []
                        ()
                        [
                          (let $0)
                          (assign (ref $0) (int 1))
                          (let $1)
                          (assign
                            (ref $1)
                            (select (ref a) [ (typename + []) ] (ref $0)))
                          (assign (ref a) (ref $1))
                          (let $2)
                          (assign
                            (ref $2)
                            (select
                              ()
                              [ (typename continue []) (typename create []) ]
                              ()))
                          (ref $2)
                        ]))
                    (let $6)
                    (assign
                      (ref $6)
                      (select (ref $4) [ (typename apply []) ] (ref $5)))
                    (let $7)
                    (assign
                      (ref $7)
                      (lambda
                        []
                        []
                        ()
                        [
                          (let $0)
                          (assign
                            (ref $0)
                            (select
                              ()
                              [ (typename break []) (typename create []) ]
                              ()))
                          (ref $0)
                        ]))
                    (let $8)
                    (assign
                      (ref $8)
                      (select (ref $6) [ (typename else []) ] (ref $7)))
                    (ref $8)
                  ]))
              (let $4)
              (assign
                (ref $4)
                (select (ref $2) [ (typename apply []) ] (ref $3)))
              (let $5)
              (assign (ref $5) (select (ref $4) [ (typename for []) ] (ref x)))
              (let $6)
              (assign
                (ref $6)
                (lambda
                  []
                  [ (param b () ()) ]
                  ()
                  [
                    (let $0)
                    (assign (ref $0) (select () [ (typename foo []) ] (ref b)))
                    (ref $0)
                  ]))
              (let $7)
              (assign
                (ref $7)
                (select (ref $5) [ (typename apply []) ] (ref $6)))
              (let $8)
              (assign
                (ref $8)
                (select
                  (ref $7)
                  [ (typename return []) (typename create []) ]
                  (ref a)))
              (ref $8)
            ]))
      ])
    (class
      $module-1
      []
      ()
      [
        (function
          ~
          (lambda
            [
              (typeparam T () ())
              (typeparamlist U () ())
              (typeparam V () ())
              (typeparam
                R
                (functiontype (typelist U) (typeref [ (typename V []) ]))
                ())
            ]
            [
              (param
                f
                (viewtype
                  (typeref [ (typename R []) ])
                  (functiontype
                    (tupletype [ (typeref [ (typename T []) ]) (typelist U) ])
                    (typeref [ (typename V []) ])))
                ())
              (param
                x
                (viewtype
                  (typeref [ (typename R []) ])
                  (typeref [ (typename T []) ]))
                ())
            ]
            (typeref [ (typename R []) ])
            [
              (let $0)
              (assign
                (ref $0)
                (lambda
                  []
                  [ (param y (typelist U) ()) ]
                  ()
                  [
                    (freelet f)
                    (freelet x)
                    (let $0)
                    (assign (ref $0) (tuple [ (ref x) (ref y) ]))
                    (let $1)
                    (assign
                      (ref $1)
                      (select (ref f) [ (typename apply []) ] (ref $0)))
                    (ref $1)
                  ]))
              (ref $0)
            ]))
        (function
          |>
          (lambda
            [ (typeparamlist T () ()) (typeparam U () ()) ]
            [
              (param x (typelist T) ())
              (param
                y
                (functiontype (typelist T) (typeref [ (typename U []) ]))
                ())
            ]
            (typeref [ (typename U []) ])
            [
              (let $0)
              (assign (ref $0) (select (ref y) [ (typename apply []) ] (ref x)))
              (ref $0)
            ]))
        (class FalseBranch [] () [])
        (function
          if
          (lambda
            [ (typeparam T () ()) ]
            [
              (param
                cond
                (functiontype (tupletype []) (typeref [ (typename Bool []) ]))
                ())
            ]
            (functiontype
              (functiontype (tupletype []) (typeref [ (typename T []) ]))
              (uniontype
                [
                  (typeref
                    [ (typename Done [ (typeref [ (typename T []) ]) ]) ])
                  (typeref [ (typename FalseBranch []) ])
                ]))
            [
              (let $0)
              (assign
                (ref $0)
                (lambda
                  []
                  [ (param ontrue () ()) ]
                  ()
                  [
                    (freelet cond)
                    (let $0)
                    (assign
                      (ref $0)
                      (select (ref cond) [ (typename apply []) ] ()))
                    (let $1)
                    (assign
                      (ref $1)
                      (lambda
                        []
                        [ (param $0 () ()) ]
                        ()
                        [
                          (let $1)
                          (assign
                            (ref $1)
                            (select
                              (param $0 () ())
                              [ (typename == []) ]
                              (ref $0)))
                          (let $2)
                          (assign
                            (ref $2)
                            (select () [ (typename requires []) ] (ref $1)))
                          (freelet ontrue)
                          (let $3)
                          (assign
                            (ref $3)
                            (select (ref ontrue) [ (typename apply []) ] ()))
                          (let $4)
                          (assign
                            (ref $4)
                            (select
                              ()
                              [ (typename Done []) (typename create []) ]
                              (ref $3)))
                          (ref $4)
                        ]))
                    (let $2)
                    (assign
                      (ref $2)
                      (lambda
                        []
                        [ (param $0 () ()) ]
                        ()
                        [
                          (let $1)
                          (assign
                            (ref $1)
                            (select
                              (param $0 () ())
                              [ (typename == []) ]
                              (ref $0)))
                          (let $2)
                          (assign
                            (ref $2)
                            (select () [ (typename requires []) ] (ref $1)))
                          (let $3)
                          (assign
                            (ref $3)
                            (select
                              ()
                              [ (typename FalseBranch []) (typename create []) ]
                              ()))
                          (ref $3)
                        ]))
                    (let $3)
                    (assign (ref $3) (match (ref $0) [ (ref $1) (ref $2) ]))
                    (ref $3)
                  ]))
              (ref $0)
            ]))
        (function
          elseif
          (lambda
            [ (typeparam T () ()) (typeparam U () ()) ]
            [
              (param
                prev
                (uniontype
                  [
                    (typeref
                      [ (typename Done [ (typeref [ (typename T []) ]) ]) ])
                    (typeref [ (typename FalseBranch []) ])
                  ])
                ())
              (param
                cond
                (functiontype (tupletype []) (typeref [ (typename Bool []) ]))
                ())
            ]
            (functiontype
              (functiontype (tupletype []) (typeref [ (typename U []) ]))
              (uniontype
                [
                  (typeref
                    [ (typename Done [ (typeref [ (typename T []) ]) ]) ])
                  (typeref
                    [ (typename Done [ (typeref [ (typename U []) ]) ]) ])
                ]))
            [
              (let $0)
              (assign
                (ref $0)
                (lambda
                  []
                  [ (param ontrue () ()) ]
                  ()
                  [
                    (freelet prev)
                    (let $0)
                    (assign
                      (ref $0)
                      (lambda
                        []
                        []
                        ()
                        [
                          (freelet cond)
                          (let $0)
                          (assign
                            (ref $0)
                            (select () [ (typename if []) ] (ref cond)))
                          (freelet ontrue)
                          (let $1)
                          (assign
                            (ref $1)
                            (select
                              (ref $0)
                              [ (typename apply []) ]
                              (ref ontrue)))
                          (ref $1)
                        ]))
                    (let $1)
                    (assign
                      (ref $1)
                      (select (ref prev) [ (typename else []) ] (ref $0)))
                    (ref $1)
                  ]))
              (ref $0)
            ]))
        (function
          else
          (lambda
            [ (typeparam T () ()) (typeparam U () ()) ]
            [
              (param
                prev
                (uniontype
                  [
                    (typeref
                      [ (typename Done [ (typeref [ (typename T []) ]) ]) ])
                    (typeref [ (typename FalseBranch []) ])
                  ])
                ())
              (param
                onfalse
                (functiontype (tupletype []) (typeref [ (typename U []) ]))
                ())
            ]
            (uniontype
              [
                (typeref [ (typename Done [ (typeref [ (typename T []) ]) ]) ])
                (typeref [ (typename Done [ (typeref [ (typename U []) ]) ]) ])
              ])
            [
              (let $0)
              (assign
                (ref $0)
                (lambda
                  []
                  [ (param $0 () ()) ]
                  ()
                  [
                    (let $1)
                    (assign
                      (ref $1)
                      (select (param $0 () ()) [ (typename == []) ] (ref $0)))
                    (let $2)
                    (assign
                      (ref $2)
                      (select () [ (typename requires []) ] (ref $1)))
                    (freelet onfalse)
                    (let $3)
                    (assign
                      (ref $3)
                      (select (ref onfalse) [ (typename apply []) ] ()))
                    (let $4)
                    (assign
                      (ref $4)
                      (select
                        ()
                        [ (typename Done []) (typename create []) ]
                        (ref $3)))
                    (ref $4)
                  ]))
              (let $1)
              (assign
                (ref $1)
                (lambda
                  []
                  [
                    (param
                      v
                      (typeref
                        [ (typename Done [ (typeref [ (typename T []) ]) ]) ])
                      ())
                  ]
                  ()
                  [ (ref v) ]))
              (let $2)
              (assign (ref $2) (match (ref prev) [ (ref $0) (ref $1) ]))
              (ref $2)
            ]))
        (using (typeref [ (modulename $module-2 []) ]))
        (interface Any [] () [])
        (class None [] () [])
        (class NoCatch [] () [])
        (class
          Done
          [ (typeparam T () (typeref [ (typename None []) ])) ]
          ()
          [
            (field result (typeref [ (typename T []) ]) ())
            (function
              create
              (lambda
                [
                  (typeparam
                    R
                    (typeref
                      [ (typename Done [ (typeref [ (typename T []) ]) ]) ])
                    ())
                ]
                [
                  (param
                    from
                    (viewtype
                      (typeref [ (typename R []) ])
                      (typeref [ (typename T []) ]))
                    (ref $0))
                ]
                (typeref [ (typename R []) ])
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (lambda
                      []
                      []
                      ()
                      [
                        (let $0)
                        (assign
                          (ref $0)
                          (select
                            ()
                            [ (typename None []) (typename create []) ]
                            ()))
                        (ref $0)
                      ]))
                  (let $1)
                  (assign (ref $1) (new () (ref from)))
                  (ref $1)
                ]))
            (function
              apply
              (lambda
                [ (typeparam U () ()) ]
                [ (param x (typeref [ (typename U []) ]) ()) ]
                (typeref [ (typename U []) ])
                [ (ref x) ]))
          ])
        (class NoLabel [] () [])
        (class Break [ (typeparam L () ()) ] () [])
        (class Continue [ (typeparam L () ()) ] () [])
        (class
          break
          [ (typeparam L () (typeref [ (typename NoLabel []) ])) ]
          ()
          [
            (function
              create
              (lambda
                []
                []
                (throwtype
                  (typeref
                    [ (typename Break [ (typeref [ (typename L []) ]) ]) ]))
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (select
                      ()
                      [
                        (typename Break [ (typeref [ (typename L []) ]) ])
                        (typename create [])
                      ]
                      ()))
                  (throw (ref $0))
                ]))
          ])
        (class
          continue
          [ (typeparam L () (typeref [ (typename NoLabel []) ])) ]
          ()
          [
            (function
              create
              (lambda
                []
                []
                (throwtype
                  (typeref
                    [ (typename Continue [ (typeref [ (typename L []) ]) ]) ]))
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (select
                      ()
                      [
                        (typename Continue [ (typeref [ (typename L []) ]) ])
                        (typename create [])
                      ]
                      ()))
                  (throw (ref $0))
                ]))
          ])
        (function
          while
          (lambda
            [
              (typeparam L () (typeref [ (typename NoLabel []) ]))
              (typeparam T () ())
              (typeparam U () ())
            ]
            [
              (param
                cond
                (functiontype (tupletype []) (typeref [ (typename Bool []) ]))
                ())
            ]
            (functiontype
              (functiontype
                (tupletype [])
                (uniontype
                  [
                    (typeref [ (typename T []) ])
                    (throwtype (typeref [ (typename U []) ]))
                  ]))
              (uniontype
                [
                  (typeref [ (typename Done []) ])
                  (throwtype (typeref [ (typename U []) ]))
                ]))
            [
              (let $0)
              (assign
                (ref $0)
                (lambda
                  []
                  [ (param body () ()) ]
                  ()
                  [
                    (freelet cond)
                    (let $0)
                    (assign
                      (ref $0)
                      (select (ref cond) [ (typename apply []) ] ()))
                    (let $1)
                    (assign
                      (ref $1)
                      (lambda
                        []
                        [ (param $0 () ()) ]
                        ()
                        [
                          (let $1)
                          (assign
                            (ref $1)
                            (select
                              (param $0 () ())
                              [ (typename == []) ]
                              (ref $0)))
                          (let $2)
                          (assign
                            (ref $2)
                            (select () [ (typename requires []) ] (ref $1)))
                          (let $3)
                          (assign
                            (ref $3)
                            (lambda
                              []
                              []
                              ()
                              [
                                (freelet body)
                                (let $0)
                                (assign
                                  (ref $0)
                                  (select (ref body) [ (typename apply []) ] ()))
                                (let $1)
                                (assign
                                  (ref $1)
                                  (select
                                    ()
                                    [
                                      (typename continue [])
                                      (typename create [])
                                    ]
                                    ()))
                                (ref $1)
                              ]))
                          (let $4)
                          (assign
                            (ref $4)
                            (lambda
                              []
                              [ (param $0 () ()) ]
                              ()
                              [
                                (let $1)
                                (assign
                                  (ref $1)
                                  (select
                                    (param $0 () ())
                                    [ (typename == []) ]
                                    (ref $0)))
                                (let $2)
                                (assign
                                  (ref $2)
                                  (select
                                    ()
                                    [ (typename requires []) ]
                                    (ref $1)))
                                (let $3)
                                (assign
                                  (ref $3)
                                  (select
                                    ()
                                    [ (typename Done []) (typename create []) ]
                                    ()))
                                (ref $3)
                              ]))
                          (let $5)
                          (assign
                            (ref $5)
                            (lambda
                              []
                              [ (param $0 () ()) ]
                              ()
                              [
                                (let $1)
                                (assign
                                  (ref $1)
                                  (select
                                    (param $0 () ())
                                    [ (typename == []) ]
                                    (ref $0)))
                                (let $2)
                                (assign
                                  (ref $2)
                                  (select
                                    ()
                                    [ (typename requires []) ]
                                    (ref $1)))
                                (let $3)
                                (assign
                                  (ref $3)
                                  (select
                                    ()
                                    [
                                      (typename
                                        while
                                        [ (typeref [ (typename L []) ]) ])
                                    ]
                                    (ref cond)))
                                (freelet body)
                                (let $4)
                                (assign
                                  (ref $4)
                                  (select
                                    (ref $3)
                                    [ (typename apply []) ]
                                    (ref body)))
                                (ref $4)
                              ]))
                          (let $6)
                          (assign (ref $6) (try (ref $3) [ (ref $4) (ref $5) ]))
                          (ref $6)
                        ]))
                    (let $2)
                    (assign (ref $2) (lambda [] [] () []))
                    (let $3)
                    (assign (ref $3) (match (ref $0) [ (ref $1) (ref $2) ]))
                    (ref $3)
                  ]))
              (ref $0)
            ]))
        (class NoMatch [] () [])
        (function
          as
          (lambda
            [ (typeparam T () ()) (typeparam U () ()) ]
            [ (param value (typeref [ (typename U []) ]) ()) ]
            (uniontype
              [
                (typeref [ (typename T []) ])
                (throwtype (typeref [ (typename NoMatch []) ]))
              ])
            [
              (let $0)
              (assign
                (ref $0)
                (lambda
                  []
                  [ (param x (typeref [ (typename T []) ]) ()) ]
                  ()
                  [ (ref x) ]))
              (let $1)
              (assign
                (ref $1)
                (lambda
                  []
                  []
                  ()
                  [
                    (let $0)
                    (assign
                      (ref $0)
                      (select
                        ()
                        [ (typename NoMatch []) (typename create []) ]
                        ()))
                    (throw (ref $0))
                  ]))
              (let $2)
              (assign (ref $2) (match (ref value) [ (ref $0) (ref $1) ]))
              (ref $2)
            ]))
        (function
          requires
          (lambda
            []
            [ (param pred (typeref [ (typename Bool []) ]) ()) ]
            (uniontype
              [
                (typeref [ (typename None []) ])
                (throwtype (typeref [ (typename NoMatch []) ]))
              ])
            [
              (let $0)
              (assign (ref $0) (select () [ (typename not []) ] (ref pred)))
              (let $1)
              (assign (ref $1) (select () [ (typename if []) ] (ref $0)))
              (let $2)
              (assign
                (ref $2)
                (lambda
                  []
                  []
                  ()
                  [
                    (let $0)
                    (assign
                      (ref $0)
                      (select
                        ()
                        [ (typename NoMatch []) (typename create []) ]
                        ()))
                    (throw (ref $0))
                  ]))
              (let $3)
              (assign
                (ref $3)
                (select (ref $1) [ (typename apply []) ] (ref $2)))
              (ref $3)
            ]))
        (class
          OrEquals
          [ (typeparam T1 () ()) (typeparam T2 () ()) ]
          ()
          [
            (field
              a
              (typeref
                [ (typename Equatable [ (typeref [ (typename T1 []) ]) ]) ])
              ())
            (field
              b
              (typeref
                [ (typename Equatable [ (typeref [ (typename T2 []) ]) ]) ])
              ())
            (function
              ==
              (lambda
                []
                [
                  (param
                    self
                    (typeref
                      [
                        (typename
                          OrEquals
                          [
                            (typeref [ (typename T1 []) ])
                            (typeref [ (typename T2 []) ])
                          ])
                      ])
                    ())
                  (param
                    x
                    (uniontype
                      [
                        (typeref [ (typename T1 []) ])
                        (typeref [ (typename T2 []) ])
                      ])
                    ())
                ]
                (typeref [ (typename Bool []) ])
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (lambda
                      []
                      [ (param y (typeref [ (typename T1 []) ]) ()) ]
                      ()
                      [
                        (freelet self)
                        (let $0)
                        (assign
                          (ref $0)
                          (select (ref self) [ (typename a []) ] ()))
                        (let $1)
                        (assign
                          (ref $1)
                          (select (ref $0) [ (typename == []) ] (ref y)))
                        (ref $1)
                      ]))
                  (let $1)
                  (assign
                    (ref $1)
                    (lambda
                      []
                      [ (param y (typeref [ (typename T2 []) ]) ()) ]
                      ()
                      [
                        (freelet self)
                        (let $0)
                        (assign
                          (ref $0)
                          (select (ref self) [ (typename b []) ] ()))
                        (let $1)
                        (assign
                          (ref $1)
                          (select (ref $0) [ (typename == []) ] (ref y)))
                        (ref $1)
                      ]))
                  (let $2)
                  (assign
                    (ref $2)
                    (lambda
                      []
                      []
                      ()
                      [ (let $0) (assign (ref $0) (bool false)) (ref $0) ]))
                  (let $3)
                  (assign
                    (ref $3)
                    (match (ref x) [ (ref $0) (ref $1) (ref $2) ]))
                  (ref $3)
                ]))
          ])
        (function
          |
          (lambda
            [ (typeparam T1 () ()) (typeparam T2 () ()) ]
            [
              (param
                e1
                (typeref
                  [ (typename Equatable [ (typeref [ (typename T1 []) ]) ]) ])
                ())
              (param
                e2
                (typeref
                  [ (typename Equatable [ (typeref [ (typename T2 []) ]) ]) ])
                ())
            ]
            (typeref
              [
                (typename
                  OrEquals
                  [
                    (typeref [ (typename T1 []) ])
                    (typeref [ (typename T2 []) ])
                  ])
              ])
            [
              (let $0)
              (assign (ref $0) (tuple [ (ref e1) (ref e2) ]))
              (let $1)
              (assign
                (ref $1)
                (select
                  ()
                  [ (typename OrEquals []) (typename create []) ]
                  (ref $0)))
              (ref $1)
            ]))
        (class
          Return
          [ (typeparam T () ()) ]
          ()
          [ (field value (typeref [ (typename T []) ]) ()) ])
        (class
          return
          [ (typeparam T () (typeref [ (typename None []) ])) ]
          ()
          [
            (function
              create
              (lambda
                []
                [ (param x (typeref [ (typename T []) ]) (ref $0)) ]
                (throwtype
                  (typeref
                    [ (typename Return [ (typeref [ (typename T []) ]) ]) ]))
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (lambda
                      []
                      []
                      ()
                      [
                        (let $0)
                        (assign
                          (ref $0)
                          (select
                            ()
                            [ (typename None []) (typename create []) ]
                            ()))
                        (ref $0)
                      ]))
                  (let $1)
                  (assign
                    (ref $1)
                    (select
                      ()
                      [
                        (typename Return [ (typeref [ (typename T []) ]) ])
                        (typename create [])
                      ]
                      (ref x)))
                  (throw (ref $1))
                ]))
          ])
      ])
    (class
      $module-2
      []
      ()
      [
        (class
          Bool
          []
          ()
          [
            (function
              apply
              (lambda
                []
                [ (param self (typeref [ (typename Bool []) ]) ()) ]
                (typeref [ (typename Bool []) ])
                [ (ref self) ]))
            (function
              bool
              (lambda
                []
                [ (param self (typeref [ (typename Bool []) ]) ()) ]
                (typeref [ (typename Bool []) ])
                [ (ref self) ]))
          ])
        (interface
          ToBool
          []
          ()
          [
            (function
              bool
              (lambda
                []
                [ (param self (Self ) ()) ]
                (typeref [ (typename Bool []) ])
                []))
          ])
        (function
          and
          (lambda
            [
              (typeparam T (typeref [ (typename ToBool []) ]) ())
              (typeparam U () ())
            ]
            [
              (param a (typeref [ (typename T []) ]) ())
              (param
                b
                (functiontype (tupletype []) (typeref [ (typename U []) ]))
                ())
            ]
            (uniontype
              [ (typeref [ (typename T []) ]) (typeref [ (typename U []) ]) ])
            [
              (let $0)
              (assign (ref $0) (select () [ (typename bool []) ] (ref a)))
              (let $1)
              (assign
                (ref $1)
                (lambda
                  []
                  [ (param $0 () ()) ]
                  ()
                  [
                    (let $1)
                    (assign
                      (ref $1)
                      (select (param $0 () ()) [ (typename == []) ] (ref $0)))
                    (let $2)
                    (assign
                      (ref $2)
                      (select () [ (typename requires []) ] (ref $1)))
                    (freelet a)
                    (ref a)
                  ]))
              (let $2)
              (assign
                (ref $2)
                (lambda
                  []
                  [ (param $0 () ()) ]
                  ()
                  [
                    (let $1)
                    (assign
                      (ref $1)
                      (select (param $0 () ()) [ (typename == []) ] (ref $0)))
                    (let $2)
                    (assign
                      (ref $2)
                      (select () [ (typename requires []) ] (ref $1)))
                    (freelet b)
                    (let $3)
                    (assign
                      (ref $3)
                      (select (ref b) [ (typename apply []) ] ()))
                    (ref $3)
                  ]))
              (let $3)
              (assign (ref $3) (match (ref $0) [ (ref $1) (ref $2) ]))
              (ref $3)
            ]))
        (function
          or
          (lambda
            [
              (typeparam T (typeref [ (typename ToBool []) ]) ())
              (typeparam U () ())
            ]
            [
              (param a (typeref [ (typename T []) ]) ())
              (param
                b
                (functiontype (tupletype []) (typeref [ (typename U []) ]))
                ())
            ]
            (uniontype
              [ (typeref [ (typename T []) ]) (typeref [ (typename U []) ]) ])
            [
              (let $0)
              (assign (ref $0) (select () [ (typename bool []) ] (ref a)))
              (let $1)
              (assign
                (ref $1)
                (lambda
                  []
                  [ (param $0 () ()) ]
                  ()
                  [
                    (let $1)
                    (assign
                      (ref $1)
                      (select (param $0 () ()) [ (typename == []) ] (ref $0)))
                    (let $2)
                    (assign
                      (ref $2)
                      (select () [ (typename requires []) ] (ref $1)))
                    (freelet a)
                    (ref a)
                  ]))
              (let $2)
              (assign
                (ref $2)
                (lambda
                  []
                  [ (param $0 () ()) ]
                  ()
                  [
                    (let $1)
                    (assign
                      (ref $1)
                      (select (param $0 () ()) [ (typename == []) ] (ref $0)))
                    (let $2)
                    (assign
                      (ref $2)
                      (select () [ (typename requires []) ] (ref $1)))
                    (freelet b)
                    (let $3)
                    (assign
                      (ref $3)
                      (select (ref b) [ (typename apply []) ] ()))
                    (ref $3)
                  ]))
              (let $3)
              (assign (ref $3) (match (ref $0) [ (ref $1) (ref $2) ]))
              (ref $3)
            ]))
        (function
          not
          (lambda
            [ (typeparam T (typeref [ (typename ToBool []) ]) ()) ]
            [ (param a (typeref [ (typename T []) ]) ()) ]
            (typeref [ (typename Bool []) ])
            [
              (let $0)
              (assign (ref $0) (select () [ (typename bool []) ] (ref a)))
              (let $1)
              (assign
                (ref $1)
                (lambda
                  []
                  [ (param $0 () ()) ]
                  ()
                  [
                    (let $1)
                    (assign
                      (ref $1)
                      (select (param $0 () ()) [ (typename == []) ] (ref $0)))
                    (let $2)
                    (assign
                      (ref $2)
                      (select () [ (typename requires []) ] (ref $1)))
                    (let $3)
                    (assign (ref $3) (bool false))
                    (ref $3)
                  ]))
              (let $2)
              (assign
                (ref $2)
                (lambda
                  []
                  [ (param $0 () ()) ]
                  ()
                  [
                    (let $1)
                    (assign
                      (ref $1)
                      (select (param $0 () ()) [ (typename == []) ] (ref $0)))
                    (let $2)
                    (assign
                      (ref $2)
                      (select () [ (typename requires []) ] (ref $1)))
                    (let $3)
                    (assign (ref $3) (bool true))
                    (ref $3)
                  ]))
              (let $3)
              (assign (ref $3) (match (ref $0) [ (ref $1) (ref $2) ]))
              (ref $3)
            ]))
        (class Less [] () [])
        (class Equal [] () [])
        (class Greater [] () [])
        (typealias
          Compare
          []
          (uniontype
            [
              (typeref [ (typename Less []) ])
              (typeref [ (typename Equal []) ])
              (typeref [ (typename Greater []) ])
            ]))
        (interface
          Equatable
          [ (typeparam T () ()) ]
          ()
          [
            (function
              ==
              (lambda
                []
                [
                  (param self (Self ) ())
                  (param other (typeref [ (typename T []) ]) ())
                ]
                (typeref [ (typename Bool []) ])
                []))
            (function
              !=
              (lambda
                []
                [
                  (param self (Self ) ())
                  (param other (typeref [ (typename T []) ]) ())
                ]
                (typeref [ (typename Bool []) ])
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (select (ref self) [ (typename == []) ] (ref other)))
                  (let $1)
                  (assign (ref $1) (select () [ (typename not []) ] (ref $0)))
                  (ref $1)
                ]))
          ])
        (interface
          Comparable
          [ (typeparam T () ()) ]
          (typeref [ (typename Equatable [ (typeref [ (typename T []) ]) ]) ])
          [
            (function
              <
              (lambda
                []
                [
                  (param self (Self ) ())
                  (param other (typeref [ (typename T []) ]) ())
                ]
                (typeref [ (typename Bool []) ])
                []))
            (function
              <=
              (lambda
                []
                [
                  (param self (Self ) ())
                  (param other (typeref [ (typename T []) ]) ())
                ]
                (typeref [ (typename Bool []) ])
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (select (ref self) [ (typename < []) ] (ref other)))
                  (let $1)
                  (assign
                    (ref $1)
                    (select (ref self) [ (typename == []) ] (ref other)))
                  (let $2)
                  (assign
                    (ref $2)
                    (select (ref $0) [ (typename or []) ] (ref $1)))
                  (ref $2)
                ]))
            (function
              >=
              (lambda
                []
                [
                  (param self (Self ) ())
                  (param other (typeref [ (typename T []) ]) ())
                ]
                (typeref [ (typename Bool []) ])
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (select (ref self) [ (typename < []) ] (ref other)))
                  (let $1)
                  (assign (ref $1) (select () [ (typename not []) ] (ref $0)))
                  (ref $1)
                ]))
            (function
              >
              (lambda
                []
                [
                  (param self (Self ) ())
                  (param other (typeref [ (typename T []) ]) ())
                ]
                (typeref [ (typename Bool []) ])
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (select (ref self) [ (typename <= []) ] (ref other)))
                  (let $1)
                  (assign (ref $1) (select () [ (typename not []) ] (ref $0)))
                  (ref $1)
                ]))
            (function
              <=>
              (lambda
                []
                [
                  (param self (Self ) ())
                  (param other (typeref [ (typename T []) ]) ())
                ]
                (typeref [ (typename Compare []) ])
                [
                  (let $0)
                  (assign
                    (ref $0)
                    (select (ref self) [ (typename < []) ] (ref other)))
                  (let $1)
                  (assign (ref $1) (select () [ (typename if []) ] (ref $0)))
                  (let $2)
                  (assign
                    (ref $2)
                    (lambda
                      []
                      []
                      ()
                      [
                        (let $0)
                        (assign
                          (ref $0)
                          (select
                            ()
                            [ (typename Less []) (typename create []) ]
                            ()))
                        (ref $0)
                      ]))
                  (let $3)
                  (assign
                    (ref $3)
                    (select (ref $1) [ (typename apply []) ] (ref $2)))
                  (let $4)
                  (assign
                    (ref $4)
                    (select (ref self) [ (typename == []) ] (ref other)))
                  (let $5)
                  (assign
                    (ref $5)
                    (select (ref $3) [ (typename elseif []) ] (ref $4)))
                  (let $6)
                  (assign
                    (ref $6)
                    (lambda
                      []
                      []
                      ()
                      [
                        (let $0)
                        (assign
                          (ref $0)
                          (select
                            ()
                            [ (typename Equal []) (typename create []) ]
                            ()))
                        (ref $0)
                      ]))
                  (let $7)
                  (assign
                    (ref $7)
                    (select (ref $5) [ (typename apply []) ] (ref $6)))
                  (let $8)
                  (assign
                    (ref $8)
                    (lambda
                      []
                      []
                      ()
                      [
                        (let $0)
                        (assign
                          (ref $0)
                          (select
                            ()
                            [ (typename Greater []) (typename create []) ]
                            ()))
                        (ref $0)
                      ]))
                  (let $9)
                  (assign
                    (ref $9)
                    (select (ref $7) [ (typename else []) ] (ref $8)))
                  (ref $9)
                ]))
          ])
      ])
  ])
