(class
  ()
  []
  ()
  [
    (class
      $module-0
      []
      ()
      [
        (using (typeref [ (modulename $module-1 []) ]))
        (function
          apply
          (lambda
            []
            [
              (param x (typeref [ (typename U64 []) ]) ())
              (param y (typeref [ (typename U64 []) ]) ())
            ]
            ()
            [
              (let $0)
              (assign (ref $0) (string " c-string \" ðŸ˜„ -> ðŸ˜„ "))
              (let $1)
              (assign
                (ref $1)
                (string
                  "    no indent $x + ${y} = ${x + y} $1\n      indent 2 spaces \"{no interp: $x}\""))
              (let $2)
              (assign (ref $2) (string "\n    hi\n"))
              (let $3)
              (assign (ref $3) (char "{\n  }"))
              (let tab)
              (let $4)
              (assign (ref $4) (string "\t"))
              (assign (ref tab) (ref $4))
              (let $5)
              (assign (ref $5) (string "    look, a "))
              (let $6)
              (assign
                (ref $6)
                (select (ref $5) [ (typename apply []) ] (ref tab)))
              (let $7)
              (assign (ref $7) (string " in my string"))
              (let $8)
              (assign
                (ref $8)
                (select (ref $6) [ (typename apply []) ] (ref $7)))
              (ref $8)
            ]))
      ])
    (class
      $module-1
      []
      ()
      [
        (class I8 [] () [])
        (class I16 [] () [])
        (class I32 [] () [])
        (class I64 [] () [])
        (class I128 [] () [])
        (class ISize [] () [])
        (class U8 [] () [])
        (class U16 [] () [])
        (class U32 [] () [])
        (class U64 [] () [])
        (class U128 [] () [])
        (class USize [] () [])
        (class F32 [] () [])
        (class F64 [] () [])
      ])
  ])
